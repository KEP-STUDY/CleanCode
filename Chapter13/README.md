## 동시성

동시성과 깨끗한 코드는 양립하기 어렵다.

동시성 제어를 위해 사용되는 코드들을 깨끗하게 유지해보자.

## 동시성이 필요한 이유

동시성은 결합(Coupling)을 없애는 전략이다.

무엇(What)과 언제(When)를 분리하는 전략이다.

대표적인 동시성의 예로 Servlet 모델이 있다.

Servlet 컨테이너는 동시성을 부분적으로 관리한다.

웹 서버는 비동기적으로 서블릿을 실행해준다.

매 요청마다 쓰레드가 할당된다.

그래서 개발자는 모든 웹 요청을 관리할 필요가 없다.

그러나 동시성은 간단한 문제가 아니다.

동시성으로 인해 대량의 작업을 빠르게 처리할 수 있지만 그로 인해 발생하는 문제들을 제어하는 것은 여전히 어렵다.

## 미신과 오해

### 흔한 미신

- 동시성은 항상 성능을 높여준다?

  - 동시성은 항상 성능을 높여주지는 않는다.

- 동시성을 구현해도 설계는 변하지 않는다?
  - 단일 스레드 시스템과 다중 스레드 시스템은 설계가 다르다.
- 웹 또는 서블릿 컨테이너를 사용하면 동시성을 이해할 필요가 없다?
  - 컨테이너의 동작 방식과 동시 수정, 데드락과 같은 문제를 피할 수 있는지 알아야한다.

### 타당한 생각

- 동시성은 다소 부하를 유발한다.

- 동시성은 꽤 복잡하다.

- 일반적으로 동시성 버그는 재현이 어렵다. ( == 디버깅이 어렵다 )

- 동시성을 구현하려면 설계 전략을 재고해야한다.

결국 동시성 프로그래밍에서 **Race Condition**은 필연적이고 우리는 이것을 어떻게 방어해야할 지 고민해야한다.

## 동시성 방어 원칙

- SRP

  - SRP는 메서드/클래스/컴포넌트를 변경할 이유가 하나여야 한다는 원칙이다.
    - 동시성 코드는 다른 코드와 분리하여 관리하자

- 따름 정리 : 자료 범위를 제한하라

  - 공유 객체를 사용하는 곳을 synchronized 키워드로 보호할 것
  - 자료를 캡슐화 하라. 공유 자료를 최대한 줄여라

- 자료 사본을 사용하자

  - 아예 자료의 복사본을 사용하는 것도 좋은 방법

- 스레드는 가능한 독립적으로 구현하라

  - 다른 스레드와 자료를 공유하지 않고 독립적으로 수행되는 스레드를 구현하자

- 라이브러리를 이해하자
  - 자바에서는 스레드 환경에 안전한 컬렉션을 제공한다.
  - 자바 5부터 ConcurrentHashMap을 비롯한 여러 Thrad-Safe 컬렉션들을 사용하도록 하자

### 실행 모델을 이해하자

- Bound Resource : 다중 스레드 환경에서 사용하는 자원으로, 크기나 숫자가 제한적이다. 데이터베이스 연결, 길이가 일정한 읽기/쓰기 버퍼등이 그 예이다.

- Mutual Exclusion : 한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우
- Starvation : 한 스레드나 여러 스레드가 오랫 동안 자원을 기다리는 경우 ( OS 스케쥴러에서도 비슷한 이슈가 있음 )
- Deadlock : 여러 스레드가 서로 자원의 점유를 기다리는 경우
- Livelock : 락을 거는 단계에서 각 스레드가 서로를 방해하는 경우

### 생산자 소비자

- 생산자는 정보를 생성하고 소비자는 생성된 정보를 가져다 쓴다. 마치 Message Queue처럼 사용. 그러나 잘못하면 둘 다 대기 상태에 빠질 수 있음.

### 읽기, 쓰기

- 대부분의 경우 Write Thraed가 쓰레드 버퍼를 오랫동안 점유하기 때문에 Read Thread가 버퍼를 기다리느라 처리율이 떨어진다.

- 이로 인해 기아 현상이 생기거나 오래된 정보가 쌓인다.

- 읽기에 우선순위를 주면 기아 현상이, 쓰기에 우선 순위를 주면 처리량 하락의 결과가 초래한다.

### 식사하는 철학자들 문제

- OS에서 공부했던 그 내용

- 링크로 대체 (https://namu.wiki/w/%EC%8B%9D%EC%82%AC%ED%95%98%EB%8A%94%20%EC%B2%A0%ED%95%99%EC%9E%90%20%EB%AC%B8%EC%A0%9C)

### 동기화하는 메서드 사이에 존재하는 의존성을 이해하라

- 공유되는 객체에서는 가급적 메소드 하나만 사용하자

### 동기화 하는 부분을 작게 만들어라

- 락은 스레드를 지연시키고 부하를 가중시킨다.

- synchonized 문을 남발하지는 말자

- 그러나 임계영역은 반드시 보호해야하므로 최대한 임계영역 수를 줄이려고 노력하라

### 올바른 종료 코드는 구현이 어렵다

- 종료를 잘 해야 데드락이 생기지 않는다.

- 처음부터 종료를 설계하여 작성하라

### 스레드 코드 테스트하는 방법

- 다중 스레드의 테스트 코드는 구현하기가 어렵다.

- 다만 말이 안되는 실패를 스레드 문제로 취급하지는 말자

- 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자

- 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워넣을 수 있게 스레드 코드를 구현하자

- 프로세스 수 보다 많은 스레드를 돌려보자

  - 시스템이 스레드를 스와핑할 때도 문제가 발생한다. 스와핑이 잦을 수록 임계영역을 빼먹은 코드나 데드락을 일으키는 코드를 찾기 쉬워진다.

- 다른 플랫폼에서 돌려보자

### 결론

- 다중 스레드 코드는 올바르게 구현하기가 어렵다

- 대신 SRP는 반드시 준수하자. POJO를 사용해 스레드를 아는 코드와 모르는 코드를 분리하자

- 동시성 오류를 일으키는 잠정적인 원인을 철저히 이해하자

- 사용하는 라이브러리와 기본 알고리즘을 이해하는 것은 기본

- 보호할 코드 영역을 찾아내는 방법과 특정 코드 영역을 잠그는 방법을 이해하자

- TDD를 하자
