## 8장 경계

## 외부 코드 사용하기

경계가 왜 중요할까?

인터페이스 제공자와 사용자 사이에는 반드시 경계가 있어야한다.

Map 인터페이스의 경우 굉장히 다양한 메소드들을 제공한다.

이렇게 다양한 메소드들은 사용자가 누구든 간에 이 Map에 원소를 추가하거나 제거하는 일을 허용한다.

즉 다음과 같은 코드를 보라.

```java
Map sensors = new HashMap();
Sensor s = (Sensor)sensors.get(sensorId);
```

위 코드가 여러번 반복된다면 리팩토링의 신호라는 것을 우리는 직감해야한다. (그것이 좋은 코드의 기본이다)

물론 제네릭을 사용해서 조금 더 명확하게 해줄 수는 있지만 그것 또한 완벽하게 문제를 해결하지 못한다.

객체지향 관점에서 보았을 때 Sensors라는 객체가 사용자에게 필요한 메소드를 제공하는 것이 조금 더 응집도가 높아보인다.

```java
public Class Sensors {
    private Map sensors = new HashMap();

    public Sensors getById(String id) {
        retrun (Sensors) sensors.get(id);
    }
}
```

만약 (그럴일은 없지만) Map 인터페이스가 변하더라도 변경은 최소화되었다.

Sensors 클래스 내부에서 우리는 메소드를 정의했고 사용자는 우리가 제공하는 메소드만을 사용하기 때문이다.

## 경계 살피고 익히기

외부 코드를 사용할 때는 외부에서 만들었기 때문에 버그가 생길 때 찾아내기가 어렵다.

저자는 외부 코드를 사용할 때는 테스트 코드를 작성해서 API를 호출하여 올바르게 작동하는지를 테스트해보라고 한다. (당연한거 아닌가?)

## log4j

log4j는 자바 진영에서 사용하는 로깅 라이브러리이다.

```java
@Test
public void testLogCreate() {
    Logger logger = Logger.getLogger("MyLogger");
    logger.info("Hello);
}
```

이 테스트 케이스는 에러가 발생한다고 한다 (참고로 Springboot에서는 SLF4J와 Logback을 사용한다. )

에러의 원인은 log4j에 Console Appender가 없어서 그렇다고 한다.

그래서 이 책의 저자는 여기서 여러가지 오류를 겪으면서 이 문제를 해결해나가는데, 결과적으로는 Console Appender는 필요가 없었다.

즉, 이 책의 저자가 여기서 말하고 싶었던 것은 외부 라이브러리를 사용하기 위해서 **테스트 코드**를 사용할 것을 강조하고 있고,

그 테스트 코드로 라이브러리를 사용할 때 캡슐화하면 훨씬 더 깔끔한 코드를 만들 수 있다는 것을 말하고 있다.

## 학습 테스트는 공짜 이상

그러니 학습 테스트 하셈 짱짱맨

라이브러리에대한 학습 테스트를 만들어두면 새로운 버전이 호환 안될 때 마다 이 테스트가 깨질 것이고 우리는 이 사실을 바로 알 수 있다.

## 깨끗한 경계

소프트웨어 설계가 우수하면 변경에 많은 비용이 들지 않는다.

경계에 위치하는 코드는 깔끔히 분리하자.

또한 테스트 코드도 잘 작성해두자.

외부 패키지를 사용하는 것도 테스트 코드를 작성해두자.

만약 외부 패키지를 쓴다면 새로운 클래스로 경계를 감싸두자.



